// Code generated by sqlitegen. DO NOT EDIT.

package example

import (
	"errors"
	"fmt"

	"crawshaw.io/sqlite"
	"seed/backend/pkg/sqlitegen"
)

var _ = errors.New

func insertWallet(conn *sqlite.Conn, walletsID string, walletsName string) error {
	const query = `INSERT INTO wallets (id, name)
VALUES (:walletsID, :walletsName)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":walletsID", walletsID)
		stmt.SetText(":walletsName", walletsName)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: insertWallet: %w", err)
	}

	return err
}

type getWalletResult struct {
	WalletsID   string
	WalletsName string
}

func getWallet(conn *sqlite.Conn, walletsID string) (getWalletResult, error) {
	const query = `SELECT wallets.id, wallets.name
FROM wallets
WHERE wallets.id = :walletsID`

	var out getWalletResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":walletsID", walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getWallet: more than one result return for a single-kind query")
		}

		out.WalletsID = stmt.ColumnText(0)
		out.WalletsName = stmt.ColumnText(1)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getWallet: %w", err)
	}

	return out, err
}

type listWalletsResult struct {
	WalletsID   string
	WalletsName string
}

func listWallets(conn *sqlite.Conn, cursor string, limit int) ([]listWalletsResult, error) {
	const query = `SELECT wallets.id, wallets.name FROM wallets WHERE wallets.id > :cursor LIMIT :limit`

	var out []listWalletsResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":cursor", cursor)
		stmt.SetInt(":limit", limit)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		out = append(out, listWalletsResult{
			WalletsID:   stmt.ColumnText(0),
			WalletsName: stmt.ColumnText(1),
		})

		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: listWallets: %w", err)
	}

	return out, err
}

func insertUser(conn *sqlite.Conn, usersID int, usersName string, usersAvatar []byte) error {
	const query = `INSERT INTO users (id, name, avatar)
VALUES (:usersID, :usersName, :usersAvatar)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":usersID", usersID)
		stmt.SetText(":usersName", usersName)
		stmt.SetBytes(":usersAvatar", usersAvatar)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: insertUser: %w", err)
	}

	return err
}

type getUserResult struct {
	UsersID     int
	UsersName   string
	UsersAvatar []byte
}

func getUser(conn *sqlite.Conn, usersID int) (getUserResult, error) {
	const query = `SELECT users.id, users.name, users.avatar
FROM users
WHERE users.id = :usersID`

	var out getUserResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetInt(":usersID", usersID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getUser: more than one result return for a single-kind query")
		}

		out.UsersID = stmt.ColumnInt(0)
		out.UsersName = stmt.ColumnText(1)
		out.UsersAvatar = stmt.ColumnBytes(2)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getUser: %w", err)
	}

	return out, err
}
