// Code generated by sqlitegen. DO NOT EDIT.

package lndhubsql

import (
	"errors"
	"fmt"

	"crawshaw.io/sqlite"
	"seed/backend/pkg/sqlitegen"
)

var _ = errors.New

type getApiURLResult struct {
	WalletsAddress string
}

func getApiURL(conn *sqlite.Conn, walletsID string) (getApiURLResult, error) {
	const query = `SELECT wallets.address FROM wallets WHERE wallets.id = :walletsID`

	var out getApiURLResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":walletsID", walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getApiURL: more than one result return for a single-kind query")
		}

		out.WalletsAddress = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getApiURL: %w", err)
	}

	return out, err
}

type getLoginResult struct {
	WalletsLogin []byte
}

func getLogin(conn *sqlite.Conn, walletsID string) (getLoginResult, error) {
	const query = `SELECT wallets.login FROM wallets WHERE wallets.id = :walletsID`

	var out getLoginResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":walletsID", walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getLogin: more than one result return for a single-kind query")
		}

		out.WalletsLogin = stmt.ColumnBytes(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getLogin: %w", err)
	}

	return out, err
}

type getPasswordResult struct {
	WalletsPassword []byte
}

func getPassword(conn *sqlite.Conn, walletsID string) (getPasswordResult, error) {
	const query = `SELECT wallets.password FROM wallets WHERE wallets.id = :walletsID`

	var out getPasswordResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":walletsID", walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getPassword: more than one result return for a single-kind query")
		}

		out.WalletsPassword = stmt.ColumnBytes(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getPassword: %w", err)
	}

	return out, err
}

type getTokenResult struct {
	WalletsToken []byte
}

func getToken(conn *sqlite.Conn, walletsID string) (getTokenResult, error) {
	const query = `SELECT wallets.token FROM wallets WHERE wallets.id = :walletsID`

	var out getTokenResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":walletsID", walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getToken: more than one result return for a single-kind query")
		}

		out.WalletsToken = stmt.ColumnBytes(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getToken: %w", err)
	}

	return out, err
}

func setToken(conn *sqlite.Conn, walletsToken []byte, walletsID string) error {
	const query = `UPDATE wallets SET (token)
=( :walletsToken ) WHERE wallets.id = :walletsID`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetBytes(":walletsToken", walletsToken)
		stmt.SetText(":walletsID", walletsID)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: setToken: %w", err)
	}

	return err
}

func setLoginSignature(conn *sqlite.Conn, kvKey string, kvValue string) error {
	const query = `INSERT OR REPLACE INTO kv (key, value)
VALUES (:kvKey, :kvValue)`

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":kvKey", kvKey)
		stmt.SetText(":kvValue", kvValue)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: setLoginSignature: %w", err)
	}

	return err
}

type getLoginSignatureResult struct {
	KVValue string
}

func getLoginSignature(conn *sqlite.Conn, kvKey string) (getLoginSignatureResult, error) {
	const query = `SELECT kv.value FROM kv WHERE kv.key = :kvKey`

	var out getLoginSignatureResult

	before := func(stmt *sqlite.Stmt) {
		stmt.SetText(":kvKey", kvKey)
	}

	onStep := func(i int, stmt *sqlite.Stmt) error {
		if i > 1 {
			return errors.New("getLoginSignature: more than one result return for a single-kind query")
		}

		out.KVValue = stmt.ColumnText(0)
		return nil
	}

	err := sqlitegen.ExecStmt(conn, query, before, onStep)
	if err != nil {
		err = fmt.Errorf("failed query: getLoginSignature: %w", err)
	}

	return out, err
}
